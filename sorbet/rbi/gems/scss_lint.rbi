# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/scss_lint/all/scss_lint.rbi
#
# scss_lint-0.59.0

module SCSSLint
end
module SCSSLint::Exceptions
end
class SCSSLint::Exceptions::InvalidCLIOption < StandardError
end
class SCSSLint::Exceptions::InvalidConfiguration < StandardError
end
class SCSSLint::Exceptions::LinterError < StandardError
end
class SCSSLint::Exceptions::NoFilesError < StandardError
end
class SCSSLint::Exceptions::RequiredLibraryMissingError < StandardError
end
class SCSSLint::Exceptions::PluginGemLoadError < StandardError
end
class SCSSLint::Exceptions::PreprocessorError < StandardError
end
class SCSSLint::Config
  def ==(other); end
  def [](key); end
  def default_plugin_options(linter); end
  def disable_all_linters; end
  def disable_linter(linter); end
  def enable_linter(linter); end
  def enabled_linters; end
  def ensure_linters_have_default_options(linters); end
  def exclude_file(file_path); end
  def exclude_patterns; end
  def excluded_file?(file_path); end
  def excluded_file_for_linter?(file_path, linter); end
  def extend(config); end
  def file; end
  def initialize(options, file = nil); end
  def linter_enabled?(linter); end
  def linter_options(linter); end
  def load_plugins; end
  def options; end
  def scss_files; end
  def self.apply_options_to_matching_linters(class_name_glob, current_options, linter_options); end
  def self.convert_single_options_to_arrays(options); end
  def self.default; end
  def self.default_options_hash; end
  def self.ensure_exclude_paths_are_absolute(options, original_file); end
  def self.ensure_linter_exclude_paths_are_absolute(options, original_file); end
  def self.ensure_severities_are_valid(options); end
  def self.linter_name(linter); end
  def self.linter_names_matching_glob(class_name_glob); end
  def self.load(file, options = nil); end
  def self.load_file_contents(file); end
  def self.load_options_hash_from_file(file); end
  def self.merge_wildcard_linter_options(options); end
  def self.path_relative_to_config(relative_include_path, base_config_path); end
  def self.severity_is_valid?(options); end
  def self.smart_merge(parent, child); end
  def self.user_file; end
  def validate_linters; end
  def warnings; end
end
class SCSSLint::FileEncodingError < StandardError
end
class SCSSLint::Engine
  def any_control_commands; end
  def build(options); end
  def build_from_file(options); end
  def build_from_string(scss); end
  def contents; end
  def filename; end
  def find_any_control_commands; end
  def initialize(options = nil); end
  def lines; end
  def preprocess_contents; end
  def tree; end
end
class SCSSLint::Location
  def <=>(other); end
  def ==(other); end
  def column; end
  def eql?(other); end
  def initialize(line = nil, column = nil, length = nil); end
  def length; end
  def line; end
  include Comparable
end
class SCSSLint::Lint
  def description; end
  def error?; end
  def filename; end
  def initialize(linter, filename, location, description, severity = nil); end
  def linter; end
  def location; end
  def severity; end
end
class SCSSLint::NoSuchLinter < StandardError
end
module SCSSLint::LinterRegistry
  def self.extract_linters_from(linter_names); end
  def self.included(base); end
  def self.linters; end
end
class SCSSLint::Logger
  def bold(output); end
  def bold_error(output, newline = nil); end
  def bold_red(output); end
  def color(code, output); end
  def color_enabled; end
  def color_enabled=(arg0); end
  def cyan(output); end
  def error(output, newline = nil); end
  def green(output); end
  def info(output, newline = nil); end
  def initialize(out); end
  def log(output, newline = nil); end
  def magenta(output); end
  def newline; end
  def red(output); end
  def self.silent; end
  def success(output, newline = nil); end
  def tty?; end
  def warning(output, newline = nil); end
  def yellow(output); end
end
class SCSSLint::FileFinder
  def extract_files_from(list); end
  def find(patterns); end
  def initialize(config); end
  def scssish_file?(file); end
end
class SCSSLint::Runner
  def files; end
  def find_lints(file); end
  def initialize(config); end
  def lints; end
  def run(files); end
  def run_linter(linter, engine, file_path); end
end
module SCSSLint::SelectorVisitor
  def selector_node_name(node); end
  def visit_members(sequence); end
  def visit_selector(node); end
  def visit_selector_node(node); end
end
class SCSSLint::ControlCommentProcessor
  def after_node_visit(node); end
  def before_node_visit(node); end
  def end_line(node); end
  def extract_commands(node); end
  def filter_lints(lints); end
  def initialize(linter); end
  def last_child(node); end
  def pop_control_comment_stack(node); end
  def process_command(command, node); end
  def retrieve_comment_text(node); end
end
module SCSSLint::Utils
  def color?(string); end
  def color_hex?(string); end
  def color_keyword?(string); end
  def color_keyword_to_code(string); end
  def else_node?(node); end
  def extract_string_selectors(selector_array); end
  def node_ancestor(node, levels); end
  def node_siblings(node); end
  def pluralize(value, word); end
  def previous_node(node); end
  def remove_quoted_strings(string); end
  def same_position?(pos1, pos2); end
end
class SCSSLint::Plugins
  def all; end
  def initialize(config); end
  def load; end
  def plugin_directories; end
  def plugin_gems; end
end
class SCSSLint::Plugins::LinterGem
  def config; end
  def initialize(name); end
  def load; end
  def plugin_config; end
  def plugin_config_file; end
end
class SCSSLint::Plugins::LinterDir
  def config; end
  def initialize(dir); end
  def load; end
  def plugin_config; end
  def plugin_config_file; end
  def ruby_files; end
end
module Sass::Script
end
class Sass::Script::Value::ArgList < Sass::Script::Value::List
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Script::Value::Bool < Sass::Script::Value::Base
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Script::Value::Color < Sass::Script::Value::Base
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Script::Value::List < Sass::Script::Value::Base
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Script::Value::Map < Sass::Script::Value::Base
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Script::Value::Null < Sass::Script::Value::Base
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Script::Value::Number < Sass::Script::Value::Base
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Script::Value::String < Sass::Script::Value::Base
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Script::Tree::Funcall < Sass::Script::Tree::Node
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Script::Tree::Interpolation < Sass::Script::Tree::Node
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Script::Tree::ListLiteral < Sass::Script::Tree::Node
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Script::Tree::Literal < Sass::Script::Tree::Node
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Script::Tree::MapLiteral < Sass::Script::Tree::Node
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Script::Tree::Operation < Sass::Script::Tree::Node
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Script::Tree::Selector < Sass::Script::Tree::Node
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Script::Tree::StringInterpolation < Sass::Script::Tree::Node
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Script::Tree::UnaryOperation < Sass::Script::Tree::Node
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Script::Tree::Variable < Sass::Script::Tree::Node
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Script::Value::Base
  def children; end
  def line; end
  def node_parent; end
  def node_parent=(arg0); end
end
module Sass::Script::Tree
end
class Sass::Script::Tree::Node
  def node_parent; end
  def node_parent=(arg0); end
end
module Sass::Tree
end
class Sass::Tree::Node
  def add_line_number(node); end
  def concat_expr_lists(*expr_lists); end
  def create_variable(var_name); end
  def extract_script_nodes(list); end
  def node_parent; end
  def node_parent=(arg0); end
end
class Sass::Tree::CommentNode < Sass::Tree::Node
  def children; end
end
class Sass::Tree::DebugNode < Sass::Tree::Node
  def children; end
end
class Sass::Tree::DirectiveNode < Sass::Tree::Node
  def children; end
end
class Sass::Tree::EachNode < Sass::Tree::Node
  def children; end
end
class Sass::Tree::ExtendNode < Sass::Tree::Node
  def children; end
end
class Sass::Tree::ForNode < Sass::Tree::Node
  def children; end
end
class Sass::Tree::FunctionNode < Sass::Tree::Node
  def children; end
end
class Sass::Tree::IfNode < Sass::Tree::Node
  def children; end
end
class Sass::Tree::MixinDefNode < Sass::Tree::Node
  def children; end
end
class Sass::Tree::MixinNode < Sass::Tree::Node
  def children; end
end
class Sass::Tree::PropNode < Sass::Tree::Node
  def children; end
end
class Sass::Tree::ReturnNode < Sass::Tree::Node
  def children; end
end
class Sass::Tree::RuleNode < Sass::Tree::Node
  def children; end
end
class Sass::Tree::VariableNode < Sass::Tree::Node
  def children; end
end
class Sass::Tree::WarnNode < Sass::Tree::Node
  def children; end
end
class Sass::Tree::WhileNode < Sass::Tree::Node
  def children; end
end
class Sass::Tree::ImportNode < Sass::Tree::RootNode
  def ==(other); end
end
class SCSSLint::Linter < Sass::Tree::Visitors::Base
  def add_lint(node_or_line_or_location, message); end
  def character_at(source_position, offset = nil); end
  def config; end
  def engine; end
  def extract_location(node_or_line_or_location); end
  def initialize; end
  def lints; end
  def location_from_range(range); end
  def name; end
  def node_on_single_line?(node); end
  def offset_to(source_position, pattern, offset = nil); end
  def run(engine, config); end
  def self.inherited(linter); end
  def self.simple_name; end
  def self.simple_name=(arg0); end
  def source_from_range(source_range); end
  def visit(node); end
  def visit_children(parent); end
  def visit_comment(_node); end
  include SCSSLint::SelectorVisitor
  include SCSSLint::Utils
end
class SCSSLint::Linter::BangFormat < SCSSLint::Linter
  def check_bang(node); end
  def check_spacing(range); end
  def find_bang_offset(range); end
  def is_after_wrong?(range, offset); end
  def is_before_wrong?(range, offset); end
  def visit_extend(node); end
  def visit_prop(node); end
  def visit_variable(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::BemDepth < SCSSLint::Linter
  def check_depth(node, plural_type); end
  def visit_class(klass); end
  def visit_placeholder(placeholder); end
  def visit_root(_node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::BorderZero < SCSSLint::Linter
  def check_border(node, border_property, border_value); end
  def visit_prop(node); end
  def visit_root(_node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::ChainedClasses < SCSSLint::Linter
  def chained_class?(simple_sequence); end
  def visit_sequence(sequence); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::ColorKeyword < SCSSLint::Linter
  def add_color_lint(node, original); end
  def in_allowed_function_call?(node); end
  def in_map?(node); end
  def visit_script_color(node); end
  def visit_script_string(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::ColorVariable < SCSSLint::Linter
  def all_arguments_are_literals?(node); end
  def color_function?(node); end
  def function_in_variable_declaration?(node); end
  def in_map_declaration?(node); end
  def in_rgba_function_call?(node); end
  def in_variable_declaration?(node); end
  def literal_color_function?(node); end
  def literal_string?(script_string); end
  def record_lint(node, color); end
  def visit_script_color(node); end
  def visit_script_funcall(node); end
  def visit_script_string(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::Comment < SCSSLint::Linter
  def allowed?(node); end
  def message; end
  def valid_comment?(node); end
  def visit_comment(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::Compass < SCSSLint::Linter
end
class SCSSLint::Linter::Compass::PropertyWithMixin < SCSSLint::Linter::Compass
  def check_for_inline_block(node); end
  def check_for_properties_with_mixins(node); end
  def ignore_compass_mixin?(prop_name); end
  def visit_prop(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::DebugStatement < SCSSLint::Linter
  def visit_debug(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::DeclarationOrder < SCSSLint::Linter
  def check_children_order(sorted_children, children); end
  def check_node(node); end
  def check_order(node); end
  def important_node?(node); end
  def node_declaration_type(node); end
  def visit_media(node); end
  def visit_mixin(node); end
  def visit_rule(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::DisableLinterReason < SCSSLint::Linter
  def comment_lines(node); end
  def report_lint(node); end
  def visit_command_comment(node); end
  def visit_comment(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::DuplicateProperty < SCSSLint::Linter
  def check_properties(node); end
  def ignore_consecutive_of?(prop); end
  def property_key(prop); end
  def static_properties(node); end
  def value_as_string(value); end
  def visit_media(node); end
  def visit_mixindef(node); end
  def visit_root(_node); end
  def visit_rule(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::ElsePlacement < SCSSLint::Linter
  def check_placement(else_node, curly_on_same_line); end
  def same_line_preferred?; end
  def visit_else(if_node, else_node); end
  def visit_if(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::EmptyLineBetweenBlocks < SCSSLint::Linter
  def check(node, type); end
  def check_following_node(node, type); end
  def check_preceding_node(node, type); end
  def comment_after_closing_brace?(node, next_start_line); end
  def next_line_blank?(next_start_line); end
  def next_node(node); end
  def prev_node(node); end
  def visit_atroot(node); end
  def visit_function(node); end
  def visit_media(node); end
  def visit_mixin(node); end
  def visit_mixindef(node); end
  def visit_rule(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::EmptyRule < SCSSLint::Linter
  def visit_rule(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::Encoding < SCSSLint::Linter
end
class SCSSLint::Linter::ExtendDirective < SCSSLint::Linter
  def visit_extend(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::FinalNewline < SCSSLint::Linter
  def visit_root(_node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::HexLength < SCSSLint::Linter
  def can_be_shorter?(hex); end
  def check_hex(hex, node); end
  def expected(hex); end
  def long_hex_form(hex); end
  def short_hex_form(hex); end
  def short_style?; end
  def visit_script_color(node); end
  def visit_script_string(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::HexNotation < SCSSLint::Linter
  def check_hex(hex, node); end
  def expected(color); end
  def lowercase_style?; end
  def visit_script_color(node); end
  def visit_script_string(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::HexValidation < SCSSLint::Linter
  def check_hex(hex, node); end
  def visit_script_string(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::IdSelector < SCSSLint::Linter
  def visit_id(id); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::ImportPath < SCSSLint::Linter
  def compose_message(orig_filename); end
  def extension_ok?(str); end
  def underscore_ok?(str); end
  def visit_import(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::ImportantRule < SCSSLint::Linter
  def visit_prop(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::Indentation < SCSSLint::Linter
  def at_root_contains_inline_selector?(node); end
  def check_and_visit_children(node); end
  def check_arbitrary_indent(node, actual_indent); end
  def check_indent_width(node); end
  def check_indentation(node); end
  def check_regular_indent(node, actual_indent); end
  def check_root_ruleset_indent(node, actual_indent); end
  def lint_message(expected, actual); end
  def node_indent(node); end
  def node_indent_parent(node); end
  def nodes_on_same_line?(node1, node2); end
  def one_shift_greater_than_parent?(node, actual_indent); end
  def visit_atroot(node, &block); end
  def visit_charset(node); end
  def visit_content(node); end
  def visit_cssimport(node); end
  def visit_directive(node); end
  def visit_each(node); end
  def visit_extend(node); end
  def visit_for(node); end
  def visit_function(node); end
  def visit_if(node); end
  def visit_import(node); end
  def visit_media(node); end
  def visit_mixin(node); end
  def visit_mixindef(node); end
  def visit_prop(node); end
  def visit_return(node); end
  def visit_root(_node); end
  def visit_rule(node); end
  def visit_supports(node); end
  def visit_variable(node); end
  def visit_warn(node); end
  def visit_while(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::LeadingZero < SCSSLint::Linter
  def check_for_leading_zeros(node, original_number); end
  def visit_script_number(node); end
  def visit_script_string(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::LengthVariable < SCSSLint::Linter
  def allowed_prop?(node); end
  def extract_lengths(node); end
  def extract_lengths_from_list(*values); end
  def extract_lengths_from_string(string); end
  def lint_lengths(node); end
  def record_lint(node, length); end
  def visit_media(node); end
  def visit_mixin(node); end
  def visit_mixindef(node); end
  def visit_prop(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::MergeableSelector < SCSSLint::Linter
  def check_node(node); end
  def equal?(node1, node2); end
  def find_mergeable_node(node, seen_nodes); end
  def multiple_parent_references?(rule_node); end
  def nested?(node1, node2); end
  def node_rule(node); end
  def single_rule?(node); end
  def subrule?(rule1, rule2); end
  def visit_root(node); end
  def visit_rule(node); end
  def whitelist_contains(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::NameFormat < SCSSLint::Linter
  def check_name(node, node_type, node_text = nil); end
  def convention_explanation(type); end
  def convention_name(type); end
  def trim_underscore_prefix(name); end
  def violated_convention(name_string, type); end
  def visit_function(node); end
  def visit_mixin(node); end
  def visit_mixindef(node); end
  def visit_script_funcall(node); end
  def visit_script_variable(node); end
  def visit_variable(node); end
  def whitelist?(name); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::NestingDepth < SCSSLint::Linter
  def ignore_selectors?(node); end
  def simple_selectors(node); end
  def visit_root(_node); end
  def visit_rule(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::PlaceholderInExtend < SCSSLint::Linter
  def visit_extend(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::PrivateNamingConvention < SCSSLint::Linter
  def after_visit_all; end
  def before?(node, before_location); end
  def check_privacy(node, node_text = nil); end
  def defined_by(node); end
  def humanize_node_class(node); end
  def node_defined_earlier_in_branch?(node_to_look_in, looking_for); end
  def private?(node); end
  def register_node(node, node_text = nil); end
  def visit_mixin(node); end
  def visit_root(node); end
  def visit_script_funcall(node); end
  def visit_script_variable(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::PropertyCount < SCSSLint::Linter
  def property_count(rule_node); end
  def visit_root(_node); end
  def visit_rule(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::PropertySortOrder < SCSSLint::Linter
  def assign_groups(order); end
  def check_group_separation(sortable_prop_info); end
  def check_order(node); end
  def check_sort_order(sortable_prop_info); end
  def compare_by_order(a, b, order); end
  def compare_by_vendor(a, b); end
  def compare_properties(a, b); end
  def extract_preferred_order_from_config; end
  def ignore_property?(prop_node); end
  def lint_message(sortable_prop_info); end
  def preset_order?; end
  def specified_property?(prop_name); end
  def visit_if(node, &block); end
  def visit_media(node); end
  def visit_mixin(node); end
  def visit_prop(node, &block); end
  def visit_root(_node); end
  def visit_rule(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::PropertySpelling < SCSSLint::Linter
  def check_property(node, prefix = nil); end
  def contains_interpolation?(node); end
  def known_property?(name); end
  def visit_prop(node); end
  def visit_root(_node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::PropertyUnits < SCSSLint::Linter
  def allowed_units_for_property(property); end
  def check_units(node, property, units); end
  def visit_prop(node); end
  def visit_root(_node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::PseudoElement < SCSSLint::Linter
  def visit_pseudo(pseudo); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::QualifyingElement < SCSSLint::Linter
  def check_attribute(seq); end
  def check_class(seq); end
  def check_id(seq); end
  def seq_contains_sel_class?(seq, selector_class); end
  def visit_simple_sequence(seq); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::SelectorDepth < SCSSLint::Linter
  def max_sequence_depth(comma_sequence, current_depth); end
  def sequence_depth(sequence, current_depth); end
  def visit_root(_node); end
  def visit_rule(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::SelectorFormat < SCSSLint::Linter
  def check(node, type); end
  def convention_explanation(type); end
  def convention_name(type); end
  def violated_convention(name_string, type); end
  def visit_attribute(attribute); end
  def visit_class(klass); end
  def visit_element(element); end
  def visit_id(id); end
  def visit_placeholder(placeholder); end
  def visit_root(_node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::Shorthand < SCSSLint::Linter
  def allowed?(size); end
  def check_script_list(prop, list); end
  def check_script_literal(prop, literal); end
  def check_script_string(prop, script_string); end
  def check_shorthand(prop, node, values); end
  def condense_to_one_value?(top, right, bottom, left); end
  def condense_to_three_values?(_, right, _, left); end
  def condense_to_two_values?(top, right, bottom, left); end
  def condensed_shorthand(top, right, bottom = nil, left = nil); end
  def shorthand_values(values); end
  def visit_prop(node); end
  def visit_root(*arg0); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::SingleLinePerProperty < SCSSLint::Linter
  def check_adjacent_properties(properties); end
  def first_property_not_on_own_line?(rule, properties); end
  def single_line_rule_set?(rule); end
  def visit_rule(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::SingleLinePerSelector < SCSSLint::Linter
  def check_comma_on_own_line(node); end
  def check_multiline_sequence(node, sequence, index); end
  def check_sequence_commas(node, sequence, index); end
  def sequence_start_of_line?(sequence); end
  def visit_comma_sequence(node); end
  def visit_sequence(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::SpaceAfterComma < SCSSLint::Linter
  def check_commas_after_args(args, arg_type); end
  def check_definition(node, type); end
  def check_invocation(node, type); end
  def find_comma_position(arg); end
  def sort_args_by_position(*args); end
  def valid_spaces_after_comma?(spaces); end
  def visit_function(node); end
  def visit_mixin(node); end
  def visit_mixindef(node); end
  def visit_script_funcall(node); end
  def visit_script_listliteral(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::SpaceAfterComment < SCSSLint::Linter
  def check_for_at_least_one_space(node_or_line, whitespace); end
  def check_for_no_spaces(node_or_line, whitespace); end
  def check_for_one_space(node_or_line, whitespace); end
  def check_for_space(node_or_line, spaces); end
  def check_loud_comment(node, source); end
  def check_normal_comment(node, source); end
  def check_silent_comment(node, source); end
  def visit_comment(node); end
  def whitespace_after_comment(source, offset); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::SpaceAfterPropertyColon < SCSSLint::Linter
  def check_for_at_least_one_space(node, whitespace); end
  def check_for_at_least_one_space_or_newline(node, whitespace); end
  def check_for_no_spaces(node, whitespace); end
  def check_for_one_space(node, whitespace); end
  def check_for_one_space_or_newline(node, whitespace); end
  def check_properties_alignment(rule_node); end
  def value_offset(prop); end
  def visit_prop(node); end
  def visit_rule(node); end
  def whitespace_after_colon(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::SpaceAfterPropertyName < SCSSLint::Linter
  def property_name_colon_offset(node); end
  def visit_prop(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::SpaceAfterVariableColon < SCSSLint::Linter
  def check_for_at_least_one_space(node, whitespace); end
  def check_for_no_spaces(node, whitespace); end
  def check_for_one_space(node, whitespace); end
  def check_for_one_space_or_newline(node, whitespace); end
  def visit_variable(node); end
  def whitespace_after_colon(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::SpaceAfterVariableName < SCSSLint::Linter
  def spaces_before_colon?(node); end
  def visit_variable(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::SpaceAroundOperator < SCSSLint::Linter
  def check(node, operation_sources); end
  def one_space_exists?(match, left_newline, right_newline); end
  def source_fm_range(range); end
  def spaces_exist?(match, left_newline, right_newline); end
  def visit_script_operation(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::SpaceAroundOperator::OperationSources
  def adjust_for_interpolation; end
  def adjust_left_boundary; end
  def adjust_sources; end
  def calculate_operator_source; end
  def initialize(node, linter); end
  def no_space_msg(operator); end
  def normalize_source(source); end
  def operator_source; end
  def slide_to_the_left(range); end
  def space_msg(operator); end
end
class SCSSLint::Linter::SpaceBeforeBrace < SCSSLint::Linter
  def chars_before_incorrect(string); end
  def check_for_space(node, string); end
  def check_node(node); end
  def newline_before_nonwhitespace(string); end
  def single_space_before(string); end
  def visit_each(node); end
  def visit_for(node); end
  def visit_function(node); end
  def visit_if(node, &block); end
  def visit_mixin(node); end
  def visit_mixindef(node); end
  def visit_rule(node); end
  def visit_while(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::SpaceBetweenParens < SCSSLint::Linter
  def check(node, source); end
  def check_node(node); end
  def expected_spaces; end
  def feel_for_enclosing_parens(node); end
  def feel_for_parens_and_check_node(node); end
  def trim_right_paren(source); end
  def visit_atroot(node); end
  def visit_cssimport(node); end
  def visit_function(node); end
  def visit_media(node); end
  def visit_mixin(node); end
  def visit_mixindef(node); end
  def visit_script_funcall(node); end
  def visit_script_listliteral(node); end
  def visit_script_mapliteral(node); end
  def visit_script_operation(node); end
  def visit_script_string(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::StringQuotes < SCSSLint::Linter
  def check_double_quotes(node, string); end
  def check_quotes(node, source); end
  def check_single_quotes(node, string); end
  def extract_string_without_quotes(source); end
  def visit_import(node); end
  def visit_script_string(node); end
  def visit_script_stringinterpolation(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::Syntax < SCSSLint::Linter
end
class SCSSLint::Linter::TrailingSemicolon < SCSSLint::Linter
  def check_semicolon(node); end
  def ends_with_multiple_semicolons?(node); end
  def ends_with_semicolon?(node); end
  def has_space_before_semicolon?(node); end
  def semicolon_after_parenthesis?(node); end
  def visit_extend(node); end
  def visit_import(node); end
  def visit_mixin(node); end
  def visit_prop(node); end
  def visit_variable(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::TrailingWhitespace < SCSSLint::Linter
  def visit_root(_node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::TrailingZero < SCSSLint::Linter
  def check_for_trailing_zeros(node, original_number); end
  def visit_script_number(node); end
  def visit_script_string(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::TransitionAll < SCSSLint::Linter
  def check_transition(node, property, value); end
  def visit_prop(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::UnnecessaryMantissa < SCSSLint::Linter
  def unnecessary_mantissa?(mantissa); end
  def url_literal?(node); end
  def visit_script_number(node); end
  def visit_script_string(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::UnnecessaryParentReference < SCSSLint::Linter
  def isolated_parent?(sequence); end
  def sequence_contains_parent_reference?(simple_sequence); end
  def sequence_starts_with_parent?(simple_sequence); end
  def visit_comma_sequence(comma_sequence); end
  def visit_sequence(sequence); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::UrlFormat < SCSSLint::Linter
  def check_url(url, node); end
  def url_literal?(prop_value); end
  def url_string?(arg); end
  def visit_prop(node); end
  def visit_script_funcall(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::UrlQuotes < SCSSLint::Linter
  def check(node, string); end
  def visit_prop(node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::VariableForProperty < SCSSLint::Linter
  def ignored_value?(value); end
  def variable_property_with_important?(value); end
  def visit_prop(node); end
  def visit_root(_node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::VendorPrefix < SCSSLint::Linter
  def check_identifier(node, identifier); end
  def check_node(node); end
  def extract_identifiers_from_config; end
  def visit_directive(node); end
  def visit_prop(node); end
  def visit_pseudo(node); end
  def visit_root(_node); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Linter::ZeroUnit < SCSSLint::Linter
  def visit_script_funcall(node); end
  def visit_script_number(node); end
  def visit_script_string(node); end
  def zero_with_length_units?(string); end
  include SCSSLint::LinterRegistry
end
class SCSSLint::Reporter
  def files; end
  def initialize(lints, files, logger); end
  def lints; end
  def log; end
  def report_lints; end
  def self.descendants; end
end
class SCSSLint::Reporter::CleanFilesReporter < SCSSLint::Reporter
  def report_lints; end
end
class SCSSLint::Reporter::ConfigReporter < SCSSLint::Reporter
  def disabled_linters; end
  def linter_name(linter); end
  def linters; end
  def report_lints; end
end
class SCSSLint::Reporter::DefaultReporter < SCSSLint::Reporter
  def location(lint); end
  def message(lint); end
  def report_lints; end
  def type(lint); end
end
class SCSSLint::Reporter::FilesReporter < SCSSLint::Reporter
  def report_lints; end
end
class SCSSLint::Reporter::JSONReporter < SCSSLint::Reporter
  def issue_hash(lint); end
  def report_lints; end
end
class SCSSLint::Reporter::StatsReporter < SCSSLint::Reporter
  def organize_stats; end
  def report_lints; end
end
class SCSSLint::Reporter::TAPReporter < SCSSLint::Reporter
  def format_files(files, lints); end
  def format_not_ok(lint, test_number); end
  def format_ok(file, test_number); end
  def format_output(output); end
  def format_plan(files, lints); end
  def group_lints_by_filename(lints); end
  def location(lint); end
  def message(lint); end
  def report_lints; end
  def type(lint); end
end
